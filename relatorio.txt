Trabalho 1 de AA 2018.2
Grupo: Francisco & Lauro


Questão 1.1

Algoritmo que garante que o número de quedas é da ordem de O(sqrt(n)) e que a
determinação do valor é garantida.

Descrição do Algoritmo:

Step 1 -> Testar alturas múltiplas de sqrt(N) até que o primeiro frasco quebre.
Sabemos que essa altura pode ser escrita da forma X * sqrt(N), com X >= 1

Step 2 -> Sabendo que o primeiro frasco quebrou na altura hQuebra = X * sqrt(N)
e que ele não quebrou em (X - 1) * sqrt(N), vamos utilizar o segundo frasco
para testar todas as alturas no intervalo semiaberto ( (X - 1) * sqrt(N), X
* sqrt(N) ], começando da menor altura e aumentando de 1 em 1. A altura em que
o frasco 2 quebrar é a altura mínima da qual um frasco quebra.


Corretude:
Como sabemos que existe uma altura crítica no intervalo [1, N], sabemos que
existe um primeiro múltiplo de sqrt(N), para qual x * sqrt(N) >= alturaCritica.
Após encontrar esse primeiro múltiplo, ficamos com um intervalo de tamanho =
sqrt(N) para percorrer de maneira crescente a fim de estipular a primeira
altura desse intervalo em que o frasco quebra. Essa altura está no intervalo de
tamanho sqrt(N) por construção.

Análise de complexidade:

Step 1 -> Sabemos que a quantidade de múltiplos de sqrt(N) <= N é => sqrt(N).
Isso nos diz que serão realizados no máximo sqrt(N) testes na primeira parte.

Step 2 -> O intervalo no qual serão realizados testes em todas as alturas até
que seja encontrada a altura de quebra tem tamanho exatamente igual a sqrt(N).
Isso também nos diz que serão realizados no máximo sqrt(N) testes na segunda
parte.

Complexidade total: O(sqrt(N)) + O(sqrt(N)) = O(sqrt(N))



Questão 1.2

Algoritmo para 3 Frascos. 

Seja N o número de bits máximo necessário para representar a altura máxima de
queda. Vamos dividir esses bits em 3 partes, com cada parte tendo no máximo
ceil(N / 3) bits.

Vamos separar a altura crítica em 3 partes de tamanho <= ceil(N / 3).

hCrit = 010101...|010001...|100011...

A ideia consiste em utilizar cada frasco para descobrir uma das partes da
altura crítica.

Vamos começar encontrando os bits do grupo mais a esquerda. Inicialmente vamos
considerar todos os bits de grupos mais a esquerda como 1's.

alturaDeTeste = 0000000 | 1111111 | 1111111

Vamos testar todas as possíveis alturas, incrementando sempre um bit no valor
da parte da esquerda até que um frasco quebre.

Primeira parte:

alturas testadas -> 0000000 | 1111111 | 1111111
                    0000001 | 1111111 | 1111111
                    .
                    .
                    .
                    0101010 | 1111111 | 1111111 <- primeira altura de quebra.

Agora sabemos a resposta para os primeiros N / 3 bits. Vamos manter essa
resposta fixada na primeira parte, e testar a segunda parte mantendo os bits
como 1's.

Segunda parte:

alturas testadas -> 0101010 | 0000000 | 1111111
                    0101010 | 0000001 | 1111111
                    .
                    .
                    .
                    0101010 | 0100010 | 1111111 <- quebra do segundo frasco

Encontramos agora a resposta para a segunda parte. Vamos fixar as respostas que
encontramos e buscar os bits da parte final.

Terceira parte:

alturas testadas -> 0101010 | 0100010 | 0000000
                    0101010 | 0100010 | 0000001
                    0101010 | 0100010 | 0000010
                    .
                    .
                    .
                    0101010 | 0100010 | 1000110 -> quebrou o terceiro frasco!

O algoritmo descrito acima funciona para 3 frascos. O número total de quedas
será no máximo (3 * 2^(ceil(N / 3) ) ). Para cada um dos 3 frascos, nós
possivelmente iremos testar todos os valores de (0, 2^(ceil( N / 3) ) ), por isso
ficamos com a complexidade total mencionada acima.

O algoritmo para K = 4 é análogo. A única diferença é que N deve ser
particionado e 4 partes ao invés de 3. O número de quedas será no máximo 
(4 * 2^(ceil( N/4 ) ) ).

Para K geral, o algoritmo também segue do exposto anteriormente. Mas ao invés
de dividirmos a altura dos testes em 3 ou 4 partes, vamos dividí-la em K partes
com no máximo ceil(N / K) bits em cada parte. O resto do algoritmo é exatamente
o mesmo, vamos encontrar primeiro a valoração dos bits da parte mais a
esquerda. Depois vamos fixá-la e testar a segunda parte mais a esquerda, e isso
mantendo sempre os bits a direita da parte de teste como 1's.

No fim, a quantidade de quedas será no máximo K * 2^(ceil(N / K) ). É
importante ressaltar que estamos assumindo K < N, pois não faz sentido termos
mais frascos do que alturas possíveis de queda.


Questão 1.3

A menor complexidade assintótica possível é O(log(N)). Em seguida iremos
mostrar um algoritmo que atinge essa complexidade.

Algoritmo Log(n)

Vamos basicamente fazer uma busca binária no espaço de possíveis alturas.
Para tal, faremos uso da monotonicidade da função quebra. Seja a altura de quebra
do problema = hCrit. Vamos definir quebra(x) = (0 se x < hCrit, 1 caso contrário)

O algoritmo procede exatamente como uma busca binária. Vou descrevê-lo por alto
agora.

Seja B o número de bits máximo da altura permitida.

Low = 1, High = 2^B - 1

Enquanto Low < High:
    Mid = (Low + High) / 2
    Se quebra(Mid):
        High = Mid
    Se não:
        Low = Mid + 1

A cada passo, o espaço de busca vai de N -> ( (N / 2) + 1 ) (no pior dos casos)
Isso nos permite concluir que serão necessárias ceil(log2(maxH)) quedas.



